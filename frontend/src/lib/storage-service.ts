/**
 * Storage Service
 * 
 * Provides methods for persisting and retrieving data across app restarts.
 * Uses localStorage for client-side persistence.
 */

import { VehicleRecord } from '@/types/dashboard';

// Define storage keys with consistent namespace
const STORAGE_KEYS = {
  VEHICLE_RECORDS: 'coficab_vehicle_records',
  UPLOADED_FILES: 'coficab_uploaded_files',
  USER_PREFERENCES: 'coficab_user_preferences',
  SER_COEFFICIENTS: 'coficab_ser_coefficients',
  REGRESSION_RESULTS: 'coficab_regression_results',
  AUTH_TOKEN: 'coficab_auth_token'
};

// Interface for uploaded file metadata
export interface UploadedFile {
  id: string;
  name: string;
  filename: string;
  uploadDate: string;
  year: number;
  size: number;
  recordCount: number;
  vehicleTypes: string[];
  fileType: string;
  downloadUrl?: string;
  path?: string; // Path to the file on the server
}

// Interface for user preferences
export interface UserPreferences {
  theme: 'light' | 'dark' | 'system';
  username?: string;
  email?: string;
  defaultVehicleType: string;
  defaultDateRange: {
    type: string;
    from?: string;
    to?: string;
  };
  dashboardLayout: {
    collapsedSidebar: boolean;
    visibleCards: string[];
  };
  collapsedSidebar: boolean;
  visibleCards: string[];
  dataRetention?: string;
  autoBackup?: boolean;
  analyticsEnabled?: boolean;
  exportFormat?: string;
  apiEndpoint?: string;
}

// Interface for SER coefficients
export interface SERCoefficient {
  vehicleType: string;
  value: number;
  isAutoGenerated: boolean;
  generatedDate?: string;
  regressionId?: string;
}

/**
 * Client-side storage service
 * Uses localStorage for persistence in the browser
 */
export const ClientStorage = {
  /**
   * Save data to localStorage with proper error handling
   */
  saveData: <T>(key: string, data: T): boolean => {
    if (typeof window === 'undefined') {
      return false;
    }
    
    try {
      const serialized = JSON.stringify(data);
      
      // Check if we're exceeding localStorage limits (~5MB)
      if (serialized.length > 4.5 * 1024 * 1024) {
        console.error(`Data for key ${key} exceeds recommended storage size`);
        return false;
      }
      
      localStorage.setItem(key, serialized);
      return true;
    } catch (error) {
      console.error(`Error saving data for key ${key}:`, error);
      return false;
    }
  },

  /**
   * Load data from localStorage with proper error handling
   */
  loadData: <T>(key: string, defaultValue: T): T => {
    if (typeof window === 'undefined') {
      return defaultValue;
    }
    
    try {
      const data = localStorage.getItem(key);
      if (!data) {
        return defaultValue;
      }
      
      return JSON.parse(data) as T;
    } catch (error) {
      console.error(`Error loading data for key ${key}:`, error);
      return defaultValue;
    }
  },

  /**
   * Clear data for a specific key
   */
  clearData: (key: string): boolean => {
    if (typeof window === 'undefined') {
      return false;
    }
    
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`Error clearing data for key ${key}:`, error);
      return false;
    }
  },

  /**
   * Check if storage has a particular key
   */
  hasKey: (key: string): boolean => {
    if (typeof window === 'undefined') {
      return false;
    }
    
    return localStorage.getItem(key) !== null;
  }
};

/**
 * Storage service for the application
 * Provides specific methods for each data type
 */
const StorageService = {
  /**
   * Authentication
   */
  auth: {
    /**
     * Save authentication token
     */
    saveToken: (token: string): boolean => {
      return ClientStorage.saveData(STORAGE_KEYS.AUTH_TOKEN, token);
    },
    
    /**
     * Get authentication token
     */
    getToken: (): string | null => {
      return ClientStorage.loadData<string | null>(STORAGE_KEYS.AUTH_TOKEN, null);
    },
    
    /**
     * Clear authentication token
     */
    clearToken: (): boolean => {
      return ClientStorage.clearData(STORAGE_KEYS.AUTH_TOKEN);
    },
    
    /**
     * Check if user is authenticated
     */
    isAuthenticated: (): boolean => {
      return ClientStorage.hasKey(STORAGE_KEYS.AUTH_TOKEN);
    }
  },

  /**
   * Vehicle Records
   */
  vehicleRecords: {
    /**
     * Save vehicle records
     */
    save: (records: VehicleRecord[]): boolean => {
      return ClientStorage.saveData(STORAGE_KEYS.VEHICLE_RECORDS, records);
    },
    
    /**
     * Load vehicle records
     */
    load: (): VehicleRecord[] => {
      return ClientStorage.loadData<VehicleRecord[]>(STORAGE_KEYS.VEHICLE_RECORDS, []);
    },
    
    /**
     * Clear vehicle records
     */
    clear: (): boolean => {
      return ClientStorage.clearData(STORAGE_KEYS.VEHICLE_RECORDS);
    },
    
    /**
     * Add record to storage
     */
    addRecord: (record: VehicleRecord): boolean => {
      const records = StorageService.vehicleRecords.load();
      
      // Check if record with same ID exists
      const index = records.findIndex(r => r.id === record.id);
      if (index >= 0) {
        records[index] = record; // Replace existing record
      } else {
        records.push(record); // Add new record
      }
      
      return StorageService.vehicleRecords.save(records);
    },
    
    /**
     * Remove record from storage
     */
    removeRecord: (id: string): boolean => {
      const records = StorageService.vehicleRecords.load();
      const filteredRecords = records.filter(r => r.id !== id);
      
      if (filteredRecords.length === records.length) {
        return false; // No record was removed
      }
      
      return StorageService.vehicleRecords.save(filteredRecords);
    }
  },
  
  /**
   * Uploaded Files
   */
  uploadedFiles: {
    /**
     * Save uploaded file metadata
     */
    save: (files: UploadedFile[]): boolean => {
      return ClientStorage.saveData(STORAGE_KEYS.UPLOADED_FILES, files);
    },
    
    /**
     * Load uploaded file metadata
     */
    load: (): UploadedFile[] => {
      return ClientStorage.loadData<UploadedFile[]>(STORAGE_KEYS.UPLOADED_FILES, []);
    },
    
    /**
     * Clear uploaded file metadata
     */
    clear: (): boolean => {
      return ClientStorage.clearData(STORAGE_KEYS.UPLOADED_FILES);
    },
    
    /**
     * Add file metadata to storage
     */
    addFile: (file: UploadedFile): boolean => {
      const files = StorageService.uploadedFiles.load();
      
      // Check if file with same ID exists
      const index = files.findIndex(f => f.id === file.id);
      if (index >= 0) {
        files[index] = file; // Replace existing file
      } else {
        files.push(file); // Add new file
      }
      
      return StorageService.uploadedFiles.save(files);
    },
    
    /**
     * Remove file metadata from storage
     */
    removeFile: (id: string): boolean => {
      const files = StorageService.uploadedFiles.load();
      const filteredFiles = files.filter(f => f.id !== id);
      
      if (filteredFiles.length === files.length) {
        return false; // No file was removed
      }
      
      return StorageService.uploadedFiles.save(filteredFiles);
    }
  },
  
  /**
   * User Preferences
   */
  userPreferences: {
    /**
     * Get default preferences with correct vehicle types
     */
    getDefaults: (): UserPreferences => ({
      theme: 'system',
      defaultVehicleType: 'Camions', // Using correct vehicle type from backend
      defaultDateRange: {
        type: 'year',
      },
      dashboardLayout: {
        collapsedSidebar: false,
        visibleCards: [
          'consumption',
          'distance',
          'efficiency',
          'emissions',
        ],
      },
      collapsedSidebar: false,
      visibleCards: [
        'consumption',
        'distance',
        'efficiency',
        'emissions',
      ],
      analyticsEnabled: true,
      exportFormat: 'pdf',
    }),
    
    /**
     * Save user preferences
     */
    save: (preferences: UserPreferences): boolean => {
      return ClientStorage.saveData(STORAGE_KEYS.USER_PREFERENCES, preferences);
    },
    
    /**
     * Load user preferences
     */
    load: (): UserPreferences => {
      return ClientStorage.loadData<UserPreferences>(
        STORAGE_KEYS.USER_PREFERENCES, 
        StorageService.userPreferences.getDefaults()
      );
    },
    
    /**
     * Clear user preferences
     */
    clear: (): boolean => {
      return ClientStorage.clearData(STORAGE_KEYS.USER_PREFERENCES);
    },
    
    /**
     * Update specific preference fields
     */
    update: (updates: Partial<UserPreferences>): boolean => {
      const currentPreferences = StorageService.userPreferences.load();
      const updatedPreferences = { ...currentPreferences, ...updates };
      return StorageService.userPreferences.save(updatedPreferences);
    }
  },
  
  /**
   * SER Coefficients
   */
  serCoefficients: {
    /**
     * Save SER coefficients
     */
    save: (coefficients: SERCoefficient[]): boolean => {
      return ClientStorage.saveData(STORAGE_KEYS.SER_COEFFICIENTS, coefficients);
    },
    
    /**
     * Load SER coefficients
     */
    load: (): SERCoefficient[] => {
      return ClientStorage.loadData<SERCoefficient[]>(STORAGE_KEYS.SER_COEFFICIENTS, []);
    },
    
    /**
     * Clear SER coefficients
     */
    clear: (): boolean => {
      return ClientStorage.clearData(STORAGE_KEYS.SER_COEFFICIENTS);
    },
    
    /**
     * Get coefficient for specific vehicle type
     */
    getForVehicleType: (vehicleType: string): SERCoefficient | undefined => {
      const coefficients = StorageService.serCoefficients.load();
      // Try exact match first
      const exactMatch = coefficients.find(c => c.vehicleType === vehicleType);
      if (exactMatch) return exactMatch;
      
      // Try case-insensitive match if no exact match found
      return coefficients.find(c => 
        c.vehicleType.toLowerCase() === vehicleType.toLowerCase()
      );
    },
    
    /**
     * Set coefficient for vehicle type
     */
    setForVehicleType: (vehicleType: string, value: number, isAutoGenerated = false): boolean => {
      if (!vehicleType || typeof value !== 'number' || isNaN(value)) {
        console.error("Invalid arguments for setForVehicleType:", vehicleType, value);
        return false;
      }
      
      const coefficients = StorageService.serCoefficients.load();
      const index = coefficients.findIndex(c => c.vehicleType === vehicleType);
      
      const coefficient: SERCoefficient = {
        vehicleType,
        value,
        isAutoGenerated,
        generatedDate: new Date().toISOString()
      };
      
      if (index >= 0) {
        coefficients[index] = coefficient;
      } else {
        coefficients.push(coefficient);
      }
      
      return StorageService.serCoefficients.save(coefficients);
    }
  },
  
  /**
   * Legacy methods for backward compatibility
   */
  saveVehicleRecords: (records: VehicleRecord[]): void => {
    StorageService.vehicleRecords.save(records);
  },
  
  loadVehicleRecords: (): VehicleRecord[] => {
    return StorageService.vehicleRecords.load();
  },
  
  saveUploadedFiles: (files: UploadedFile[]): void => {
    StorageService.uploadedFiles.save(files);
  },
  
  loadUploadedFiles: (): UploadedFile[] => {
    return StorageService.uploadedFiles.load();
  },
  
  saveUserPreferences: (preferences: UserPreferences): void => {
    StorageService.userPreferences.save(preferences);
  },
  
  loadUserPreferences: (): UserPreferences => {
    return StorageService.userPreferences.load();
  },
  
  saveSERCoefficients: (coefficients: SERCoefficient[]): void => {
    StorageService.serCoefficients.save(coefficients);
  },
  
  loadSERCoefficients: (): SERCoefficient[] => {
    return StorageService.serCoefficients.load();
  },
  
  /**
   * Clear all application storage
   */
  clearAll: (): void => {
    Object.values(STORAGE_KEYS).forEach(key => {
      ClientStorage.clearData(key);
    });
  },
  
  /**
   * Get authentication token (for API calls)
   */
  getToken: (): string | null => {
    return StorageService.auth.getToken();
  }
};

export default StorageService;
